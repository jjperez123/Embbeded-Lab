// This code is a modified version of the code submitted for Lab 6
// The changes are as follows:
//
// 1. The itoa function is modified to include a parameter "prefix." Any character passed here will be attached to
//    the beginning of the string so that the values can be differentiated at the other end of the serial communication
//
// 2. The value from the ADC is converted to a percentage before being sent to the terminal for the sake of simplicity
//
// 3. The output is printed without the newline/carriage return characters
//

#include <msp430g2553.h>

volatile long tempRaw;
char result[100];
char result1[100];
volatile long sample[100];

double temp = 0;
int count = 0;
int value = 0;
int percentLight = 0;
void ConfigureAdc_temp();
void ConfigureAdc_temp2();
void uart_init(void);
void ConfigClocks(void);
void strreverse(char* begin, char* end);
void itoa(int value, char* str, int base, char prefix);
void port_init();

void main(void)
{
    WDTCTL = WDTPW + WDTHOLD; // Stop watchdog timer


    port_init();

    ConfigClocks();
    uart_init();

    _delay_cycles(5);                // Wait for ADC Ref to settle

    while(1){
                ConfigureAdc_temp();
                ADC10CTL0 |= ENC + ADC10SC +MSC;       // Converter Enable, Sampling/conversion start
                while((ADC10CTL0 & ADC10IFG) == 0);    // check the Flag, while its low just wait
                ADC10CTL0 &= ~ADC10IFG;                // clear the flag
                _delay_cycles(1000000);               // delay for about 1 second so LED doesn't flash too fast
                tempRaw = ADC10MEM;                     // read the converted data into a variable
                temp =(tempRaw * 48724 - 30634388) >> 16;
                itoa(temp,result,10, 'T');                   // convert temperature reading to Fahrenheit
                int acount =0;

                while(result[acount]!='\0')
                {
                 while((IFG2 & UCA0TXIFG)==0);                  //Wait Unitl the UART transmitter is ready

                 UCA0TXBUF = result[acount++] ;                   //Transmit the received data.
                 }

                ConfigureAdc_temp2();
                ADC10CTL0 |= ENC + ADC10SC +MSC;
                while((ADC10CTL0 & ADC10IFG) == 0);
                ADC10CTL0 &= ~ADC10IFG;                // clear the flag
                value = ADC10MEM;
                percentLight = value * 0.097656;    // convert ADC reading to a percentage using factor 100/1024

                itoa(percentLight,result,10,'L');                   // convert temperature reading to Fahrenheit
                acount =0;
                while(result[acount]!='\0')
                  {
                   while((IFG2 & UCA0TXIFG)==0);                  //Wait Unitl the UART transmitter is ready
                   UCA0TXBUF = result[acount++] ;                   //Transmit the received data.
                  }

    }
}



// Configure ADC Temperature
void ConfigureAdc_temp(){


       ADC10CTL1 =INCH_10 + ADC10DIV_0 + CONSEQ_2;
       ADC10CTL0 = SREF_1 | ADC10SHT_3 | REFON | ADC10ON ;//| ADC10IE; //Vref+, Vss, 64 ATD clocks per sample, internal references, turn ADCON

    __delay_cycles(5);        //wait for adc Ref to settle
    ADC10CTL0 |= ENC| MSC;   //converter Enable, Sampling/Conversion start, multiple sample/conversion operations
}

void ConfigureAdc_temp2(){
    ADC10CTL1 = INCH_7 + ADC10DIV_0;
    ADC10CTL0 = SREF_0 + ADC10SHT_2 + ADC10ON + ADC10IE;
    ADC10AE0 |= BIT7;
}



void uart_init(void){
    UCA0CTL1 |= UCSWRST;                     //Disable the UART state machine
    UCA0CTL1 |= UCSSEL_3;                    //Select SMCLK as the baud rate generator source
    UCA0BR1 =0;
    UCA0BR0 = 104;                           //Produce a 9,600 Baud UART rate
    UCA0MCTL = 0x02;                         //Chooa propriately from Table 15-4 in User Guide
    UCA0CTL1 &= ~UCSWRST;                    //Enable the UART state naching
    IE2 |= UCA0RXIE;                         //Enable the UART receiver Interrupt
}

void ConfigClocks(void)
 {

  BCSCTL1 = CALBC1_1MHZ;                     // Set range
  DCOCTL = CALDCO_1MHZ;                      // Set DCO step + modulation
  BCSCTL3 |= LFXT1S_2;                       // LFXT1 = VLO
  IFG1 &= ~OFIFG;                            // Clear OSCFault flag
  BCSCTL2 = 0;                               // MCLK = DCO = SMCLK
 }



void strreverse(char* begin, char* end)      // Function to reverse the order of the ASCII char array elements
{
    char aux;
    while(end>begin)
        aux=*end, *end--=*begin, *begin++=aux;
}
// note the addition of the prefix character
void itoa(int value, char* str, int base, char prefix) {  //Function to convert the signed int to an ASCII char array

    static char num[] = "0123456789abcdefghijklmnopqrstuvwxyz";
    char* wstr=str;
    int sign;

    // Validate that base is between 2 and 35 (inlcusive)
    if (base<2 || base>35){
        *wstr='\0';
        return;
    }

    // Get magnitude and th value
    sign=value;
    if (sign < 0)
        value = -value;

    do // Perform interger-to-string conversion.
        *wstr++ = num[value%base]; //create the next number in converse by taking the modolus
    while(value/=base);  // stop when you get  a 0 for the quotient

    *wstr++=prefix; // add prefix character based on parameter set at function call

    if(sign<0) //attch sign character, if needed
        *wstr++='-';
    //*wstr++='\n';
    //*wstr++='\r';
    *wstr= '\0'; //Attach a null character at end of char array. The string is in revers order at this point
    strreverse(str,wstr-1); // Reverse string

}




void port_init(){
    P1SEL |= BIT1 + BIT2;            // select non-GPIO  usage for Pins 1 and 2
    P1SEL2 |= BIT1 + BIT2;           // Select UART usage of Pins 1 and 2
}
